"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildJsEngine = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const transformer_1 = require("../../../transformer/lib/index.js");
const bundler_1 = require("../../../bundler/lib/index.js");
const fs_1 = __importDefault(require("fs"));
const ts_paths_1 = __importDefault(require("./rollup-plugins/ts-paths"));
const module_query_plugin_1 = __importDefault(require("./rollup-plugins/module-query-plugin"));
const remove_deprecated_features_1 = __importDefault(require("./rollup-plugins/remove-deprecated-features"));
const external_wasm_loader_1 = require("./rollup-plugins/external-wasm-loader");
const stats_query_1 = require("../../../stats-query/lib/index.js");
const utils_1 = require("../../../utils/lib/index.js");
var babelPluginTransformForOf = transformer_1.babel.plugins.transformForOf;
var babelPresetEnv = transformer_1.babel.presets.presetEnv;
var babelPluginDynamicImportVars = transformer_1.babel.plugins.cocosDynamicImportVars;
var babelPresetCC = transformer_1.babel.presets.presetCC.babelPresetCC;
var helpers = transformer_1.babel.presets.presetCC.helpers;
// import rollup
var rollup = bundler_1.rollup.core;
var rpBabel = bundler_1.rollup.plugins.babel.babel;
var json = bundler_1.rollup.plugins.json;
var resolve = bundler_1.rollup.plugins.nodeResolve;
var commonjs = bundler_1.rollup.plugins.commonjs;
var rpTerser = bundler_1.rollup.plugins.terser.terser;
var rpVirtual = bundler_1.rollup.plugins.virtual;
const modularize_1 = require("../../../modularize/lib/index.js");
// import rpProgress = Bundler.plugins.progress;
// import * as decoratorRecorder from './babel-plugins/decorator-parser';
const realPath = function () {
  const realpath = typeof fs_1.default.realpath.native === 'function' ? fs_1.default.realpath.native : fs_1.default.realpath;
  return file => new Promise((resolve, reject) => {
    realpath(file, (err, path) => {
      if (err && err.code !== 'ENOENT') {
        reject(err);
      } else {
        resolve(err ? file : path);
      }
    });
  });
}();
function makePathEqualityKey(path) {
  return process.platform === 'win32' ? path.toLocaleLowerCase() : path;
}
function buildJsEngine(options) {
  var _a, _b, _c, _d, _e;
  return __awaiter(this, void 0, void 0, function* () {
    const doUglify = !!options.compress;
    const engineRoot = path_1.default.resolve(options.engine);
    const rollupFormat = (_a = options.moduleFormat) !== null && _a !== void 0 ? _a : 'iife';
    const statsQuery = yield stats_query_1.StatsQuery.create(engineRoot);
    const moduleQuery = new modularize_1.ModuleQuery({
      engine: engineRoot,
      platform: options.platform
    });
    if (options.features) {
      for (const feature of options.features) {
        if (!statsQuery.hasFeature(feature)) {
          console.warn(`'${feature}' is not a valid feature.`);
        }
      }
    }
    let features;
    let split = (_b = options.split) !== null && _b !== void 0 ? _b : false;
    if (options.features && options.features.length !== 0) {
      features = options.features;
    } else {
      features = statsQuery.getFeatures();
      if (split !== true) {
        split = true;
        console.warn(`You did not specify features which implies 'split: true'. ` + `Explicitly set 'split: true' to suppress this warning.`);
      }
    }
    let {
      ammoJsWasm
    } = options;
    ammoJsWasm !== null && ammoJsWasm !== void 0 ? ammoJsWasm : ammoJsWasm = true; // default is true
    const forceBanningBulletWasm = !ammoJsWasm;
    const flags = (_c = options.flags) !== null && _c !== void 0 ? _c : {};
    flags.FORCE_BANNING_BULLET_WASM = forceBanningBulletWasm;
    const intrinsicFlags = statsQuery.getIntrinsicFlagsOfFeatures(features);
    let buildTimeConstants = statsQuery.constantManager.genBuildTimeConstants({
      mode: options.mode,
      platform: options.platform,
      flags
    });
    buildTimeConstants = Object.assign(Object.assign({}, intrinsicFlags), buildTimeConstants);
    // if (typeof options.forceJitValue !== undefined) {
    //     buildTimeConstants['SUPPORT_JIT'] = options.forceJitValue as boolean;
    // }
    const moduleOverrides = Object.entries(statsQuery.evaluateModuleOverrides({
      mode: options.mode,
      platform: options.platform,
      buildTimeConstants
    })).reduce((result, [k, v]) => {
      result[makePathEqualityKey(k)] = v;
      return result;
    }, {});
    const featureUnits = statsQuery.getUnitsOfFeatures(features);
    const rpVirtualOptions = {};
    const vmInternalConstants = statsQuery.constantManager.exportStaticConstants({
      platform: options.platform,
      mode: options.mode,
      flags
    });
    console.debug(`Module source "internal-constants":\n${vmInternalConstants}`);
    rpVirtualOptions['internal:constants'] = vmInternalConstants;
    rpVirtualOptions[helpers.CC_HELPER_MODULE] = helpers.generateHelperModuleSource();
    // for some modules that we need to instantiate before cc module
    // const forceStandaloneModules = ['wait-for-ammo-instantiation'];
    const forceStandaloneModules = [];
    let rollupEntries;
    if (split) {
      rollupEntries = featureUnits.reduce((result, featureUnit) => {
        result[featureUnit] = statsQuery.getFeatureUnitFile(featureUnit);
        return result;
      }, {});
    } else {
      rollupEntries = {
        cc: 'cc'
      };
      const selectedFeatureUnits = [];
      for (const featureUnit of featureUnits) {
        if (forceStandaloneModules.includes(featureUnit)) {
          rollupEntries[featureUnit] = statsQuery.getFeatureUnitFile(featureUnit);
        } else {
          selectedFeatureUnits.push(featureUnit);
        }
      }
      rpVirtualOptions.cc = statsQuery.evaluateIndexModuleSource(selectedFeatureUnits, featureUnit => (0, utils_1.filePathToModuleRequest)(statsQuery.getFeatureUnitFile(featureUnit)));
      rollupEntries.cc = 'cc';
      console.debug(`Module source "cc":\n${rpVirtualOptions.cc}`);
    }
    const presetEnvOptions = {
      loose: (_d = options.loose) !== null && _d !== void 0 ? _d : true,
      // We need explicitly specified targets.
      // Ignore it to avoid the engine's parent dirs contain unexpected config.
      ignoreBrowserslistConfig: true
    };
    if (options.targets) {
      presetEnvOptions.targets = options.targets;
    }
    const babelPlugins = [];
    if (!options.targets) {
      babelPlugins.push([babelPluginTransformForOf, {
        loose: true
      }]);
    }
    babelPlugins.push([babelPluginDynamicImportVars, {
      resolve: {
        forwardExt: 'resolved'
      }
    }]);
    const {
      fieldDecorators,
      editorDecorators
    } = statsQuery.getOptimizeDecorators();
    const babelOptions = {
      babelHelpers: 'bundled',
      extensions: ['.js', '.ts'],
      exclude: [/node_modules[/\\]@cocos[/\\]ammo/, /node_modules[/\\]@cocos[/\\]cannon/, /node_modules[/\\]@cocos[/\\]physx/, /\.asm\.js/],
      comments: false,
      overrides: [{
        // Eliminates the babel compact warning:
        // 'The code generator has deoptimised the styling of ...'
        // that came from node_modules/@cocos
        test: /node_modules[/\\]@cocos[/\\]/,
        compact: true
      }],
      plugins: babelPlugins,
      presets: [[babelPresetEnv, presetEnvOptions], [babelPresetCC, {
        allowDeclareFields: true,
        ccDecoratorHelpers: 'external',
        fieldDecorators,
        editorDecorators
      }]]
    };
    // if (options.generateDecoratorsForJSB) {
    //     if (!process.env.ENGINE_PATH) {
    //         throw new Error('ENGINE_PATH environment variable not set');
    //     }
    //     babelOptions.presets?.push([() => ({ plugins: [[decoratorRecorder]] })]);
    // }
    const rollupPlugins = [];
    if (options.noDeprecatedFeatures) {
      rollupPlugins.push((0, remove_deprecated_features_1.default)(typeof options.noDeprecatedFeatures === 'string' ? options.noDeprecatedFeatures : undefined));
    }
    rollupPlugins.push((0, external_wasm_loader_1.externalWasmLoader)({
      externalRoot: path_1.default.join(engineRoot, 'native/external'),
      wasmSupportMode: buildTimeConstants.WASM_SUPPORT_MODE,
      forceBanningBulletWasm,
      cullAsmJsModule: buildTimeConstants.CULL_ASM_JS_MODULE,
      cullMeshopt: buildTimeConstants.CULL_MESHOPT,
      format: 'relative-from-chunk',
      wasmFallback: buildTimeConstants.WASM_FALLBACK,
      wasmSubpackage: buildTimeConstants.WASM_SUBPACKAGE
    }), {
      name: '@cocos/ccbuild|module-overrides',
      resolveId(source, importer) {
        if (moduleOverrides[source]) {
          return source;
        } else {
          return null;
        }
      },
      load(id) {
        const key = makePathEqualityKey(id);
        if (!(key in moduleOverrides)) {
          return null;
        }
        const replacement = moduleOverrides[key];
        console.debug(`Redirect module ${id} to ${replacement}`);
        return `export * from '${(0, utils_1.filePathToModuleRequest)(replacement)}';`;
      }
    }, rpVirtual(rpVirtualOptions), (0, module_query_plugin_1.default)(moduleQuery), (0, ts_paths_1.default)({
      configFileName: path_1.default.resolve(options.engine, 'tsconfig.json')
    }), resolve({
      extensions: ['.js', '.ts', '.json'],
      jail: yield realPath(engineRoot),
      rootDir: engineRoot
    }), json({
      preferConst: true
    }), commonjs({
      include: [/node_modules[/\\]/, /asm\.js/],
      sourceMap: false
    }), rpBabel(Object.assign({
      skipPreflightCheck: true
    }, babelOptions)));
    // if (options.progress) {
    //     rollupPlugins.unshift(rpProgress());
    // }
    if (doUglify) {
      // TODO: tree-shaking not clear!
      rollupPlugins.push(rpTerser({
        // see https://github.com/terser/terser#compress-options
        compress: {
          reduce_funcs: false,
          keep_fargs: false,
          unsafe_Function: true,
          unsafe_math: true,
          unsafe_methods: true,
          passes: 2 // first: remove deadcodes and const objects, second: drop variables
        },

        mangle: doUglify,
        keep_fnames: !doUglify,
        output: {
          beautify: !doUglify
        },
        // https://github.com/rollup/rollup/issues/3315
        // We only do this for CommonJS.
        // Especially, we cannot do this for IIFE.
        toplevel: rollupFormat === 'cjs'
      }));
    }
    // const visualizeOptions = typeof options.visualize === 'object'
    //     ? options.visualize
    //     : (options.visualize ? {} : undefined);
    // if (visualizeOptions) {
    //     let rpVisualizer;
    //     try {
    //         // @ts-expect-error: No typing
    //         rpVisualizer = await import('rollup-plugin-visualizer');
    //     } catch {
    //         console.warn('Visualizing needs \'rollup-plugin-visualizer\' to be installed. It\'s installed as dev-dependency.');
    //     }
    //     if (rpVisualizer) {
    //         const visualizeFile = visualizeOptions.file ?? ps.join(options.out, 'visualize.html');
    //         rollupPlugins.push(rpVisualizer({
    //             filename: visualizeFile,
    //             title: 'Cocos Creator build visualizer',
    //             template: 'treemap',
    //         }));
    //     }
    // }
    let hasCriticalWarns = false;
    const rollupWarningHandler = (warning, defaultHandler) => {
      var _a;
      if (typeof warning !== 'string') {
        if (warning.code === 'CIRCULAR_DEPENDENCY') {
          hasCriticalWarns = true;
        } else if (warning.code === 'THIS_IS_UNDEFINED') {
          // TODO: It's really inappropriate to do this...
          // Let's fix these files instead of suppressing rollup.
          if ((_a = warning.id) === null || _a === void 0 ? void 0 : _a.match(/(?:spine-core\.js$)|(?:dragonBones\.js$)/)) {
            console.debug(`Rollup warning 'THIS_IS_UNDEFINED' is omitted for ${warning.id}`);
            return;
          }
        }
      }
      defaultHandler(warning);
    };
    const rollupOptions = {
      input: rollupEntries,
      plugins: rollupPlugins,
      cache: false,
      onwarn: rollupWarningHandler
    };
    const perf = true;
    if (perf) {
      rollupOptions.perf = true;
    }
    const rollupBuild = yield rollup.rollup(rollupOptions);
    const timing = (_e = rollupBuild.getTimings) === null || _e === void 0 ? void 0 : _e.call(rollupBuild);
    if (timing) {
      console.debug(`==== Performance ====`);
      console.debug(JSON.stringify(timing));
      console.debug(`====             ====`);
    }
    const {
      incremental: incrementalFile
    } = options;
    if (incrementalFile) {
      const watchFiles = {};
      const files = rollupBuild.watchFiles;
      yield Promise.all(files.map(watchFile => __awaiter(this, void 0, void 0, function* () {
        try {
          const stat = yield fs_extra_1.default.stat(watchFile);
          watchFiles[watchFile] = stat.mtimeMs;
        } catch (_f) {
          // the `watchFiles` may contain non-fs modules.
        }
      })));
      yield fs_extra_1.default.ensureDir(path_1.default.dirname(incrementalFile));
      yield fs_extra_1.default.writeFile(incrementalFile, JSON.stringify(watchFiles, undefined, 2));
    }
    const result = {
      chunkAliases: {},
      exports: {},
      chunkDepGraph: {},
      assetDepGraph: {},
      hasCriticalWarns: false
    };
    const rollupOutputOptions = {
      format: rollupFormat,
      sourcemap: options.sourceMap,
      sourcemapFile: options.sourceMapFile,
      name: rollupFormat === 'iife' ? 'ccm' : undefined,
      dir: options.out,
      // NOTE: parallel dynamic import has some issue on SystemJS, especially on OH platform
      // see: https://github.com/systemjs/systemjs/issues/2297
      inlineDynamicImports: options.platform === 'OPEN_HARMONY'
      // minifyInternalExports: false,
      // preserveEntrySignatures: "allow-extension",
    };

    const rollupOutput = yield rollupBuild.write(rollupOutputOptions);
    const validEntryChunks = {};
    for (const output of rollupOutput.output) {
      if (output.type === 'chunk') {
        if (output.isEntry) {
          const chunkName = output.name;
          if (chunkName in rollupEntries || chunkName === 'cc') {
            validEntryChunks[chunkName] = output.fileName;
          }
        }
      }
    }
    Object.assign(result.exports, validEntryChunks);
    result.dependencyGraph = {};
    for (const output of rollupOutput.output) {
      if (output.type === 'chunk') {
        const depList = output.imports.concat(output.dynamicImports);
        result.dependencyGraph[output.fileName] = depList;
        result.chunkDepGraph[output.fileName] = depList;
        result.assetDepGraph[output.fileName] = output.referencedFiles.slice();
      }
    }
    result.hasCriticalWarns = hasCriticalWarns;
    return result;
  });
}
exports.buildJsEngine = buildJsEngine;