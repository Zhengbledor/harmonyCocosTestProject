"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeModuleLoaderFactory = void 0;
const bundler_1 = require("../../../../bundler/lib/index.js");
var rollup = bundler_1.rollup.core;
var rpCjs = bundler_1.rollup.plugins.commonjs;
var rpNodeResolve = bundler_1.rollup.plugins.nodeResolve;
const utils_1 = require("../../../../utils/lib/index.js");
function nodeModuleLoaderFactory() {
  const resolvedModuleMap = {};
  const nodeModuleLoader = {
    resolve(source, importer) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function* () {
        if (source.startsWith('@cocos/') && importer) {
          if ((_a = resolvedModuleMap[source]) === null || _a === void 0 ? void 0 : _a.id) {
            return resolvedModuleMap[source].id;
          }
          const resolvedPath = (0, utils_1.formatPath)(require.resolve(source, {
            paths: [importer]
          }));
          (_b = resolvedModuleMap[source]) !== null && _b !== void 0 ? _b : resolvedModuleMap[source] = {
            id: resolvedPath
          };
          return resolvedPath;
        }
      });
    },
    load(id) {
      return __awaiter(this, void 0, void 0, function* () {
        for (const [source, resolvedModuleData] of Object.entries(resolvedModuleMap)) {
          if (resolvedModuleData.id === id) {
            if (resolvedModuleData.id) {
              if (resolvedModuleData.code) {
                return resolvedModuleData.code;
              }
              // bundle the node module
              const res = yield rollup.rollup({
                input: resolvedModuleData.id,
                plugins: [rpNodeResolve(), rpCjs()]
              });
              const generateRes = yield res.generate({
                format: 'es'
              });
              return resolvedModuleData.code = generateRes.output[0].code;
            }
          }
        }
      });
    },
    transformId(source, importer) {
      if (source in resolvedModuleMap) {
        const resolvedModuleData = resolvedModuleMap[source];
        if (resolvedModuleData.id) {
          return resolvedModuleData.id;
        }
      }
    }
  };
  return nodeModuleLoader;
}
exports.nodeModuleLoaderFactory = nodeModuleLoaderFactory;