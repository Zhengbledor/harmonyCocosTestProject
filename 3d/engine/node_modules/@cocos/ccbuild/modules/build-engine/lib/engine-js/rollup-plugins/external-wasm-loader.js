"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathToAssetRefURL = exports.externalWasmLoader = void 0;
const bundler_1 = require("../../../../bundler/lib/index.js");
const transformer_1 = require("../../../../transformer/lib/index.js");
const url_1 = require("url");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
var babel = transformer_1.babel.core;
var pluginTransformSystemJSModule = transformer_1.babel.plugins.transformModulesSystemjs;
var rollup = bundler_1.rollup.core;
var rpCjs = bundler_1.rollup.plugins.commonjs;
const crypto_1 = require("crypto");
const externalOrigin = 'external:';
function normalizePath(path) {
  return path.replace(/\\/g, '/');
}
const suffixReplaceConfig = {
  '.mem': '.mem.bin',
  '.wasm.fallback': '.wasm.fallback.bin'
};
/**
 * emit asset and return the export statement
 */
function emitAsset(context, filePath) {
  return __awaiter(this, void 0, void 0, function* () {
    let basename = path_1.default.basename(filePath);
    for (const suffixToReplace in suffixReplaceConfig) {
      const replacement = suffixReplaceConfig[suffixToReplace];
      if (basename.endsWith(suffixToReplace)) {
        // some platforms doesn't support files with special suffix like '.mem', we replace it to '.bin'
        basename = basename.slice(0, -suffixToReplace.length) + replacement;
      }
    }
    const source = yield fs_extra_1.default.readFile(filePath);
    const referenceId = context.emitFile({
      type: 'asset',
      name: basename,
      source
    });
    const hash = (0, crypto_1.createHash)('sha256').update(source).digest('hex').slice(0, 8);
    return `export default import.meta.ROLLUP_FILE_URL_${referenceId}; /* asset-hash:${hash} */`;
  });
}
function shouldCullBulletWasmModule(options, id) {
  return options.forceBanningBulletWasm && id.includes('bullet');
}
function shouldCullAsmJsModule(options, id) {
  return options.wasmSupportMode !== 0 && options.cullAsmJsModule;
}
function shouldCullMeshoptModule(options, id) {
  return options.cullMeshopt && id.includes('meshopt');
}
const loadConfig = {
  '.wasm': {
    shouldCullModule(options, id) {
      return options.wasmSupportMode === 0 || shouldCullBulletWasmModule(options, id) || shouldCullMeshoptModule(options, id);
    },
    shouldEmitAsset(options, id) {
      return !this.shouldCullModule(options, id);
    },
    cullingContent: `export default '';`
  },
  '.js.mem': {
    shouldCullModule(options, id) {
      return options.wasmSupportMode === 1 && !shouldCullBulletWasmModule(options, id) || shouldCullAsmJsModule(options, id) || shouldCullMeshoptModule(options, id);
    },
    shouldEmitAsset(options, id) {
      return !this.shouldCullModule(options, id);
    },
    cullingContent: `export default '';`
  },
  '.wasm.js': {
    shouldCullModule(options, id) {
      return options.wasmSupportMode === 0 || shouldCullBulletWasmModule(options, id) || shouldCullMeshoptModule(options, id);
    },
    shouldEmitAsset(options, id) {
      return false;
    },
    cullingContent: `export default function () {}`
  },
  '.asm.js': {
    shouldCullModule(options, id) {
      return options.wasmSupportMode === 1 && !shouldCullBulletWasmModule(options, id) || shouldCullAsmJsModule(options, id) || shouldCullMeshoptModule(options, id);
    },
    shouldEmitAsset(options, id) {
      return false;
    },
    cullingContent: `export default function () {}`
  },
  '.wasm.fallback': {
    shouldCullModule(options, id) {
      return loadConfig['.wasm'].shouldCullModule(options, id) || !options.wasmFallback;
    },
    shouldEmitAsset(options, id) {
      return !this.shouldCullModule(options, id);
    },
    cullingContent: `export default '';`
  },
  '.wasm.fallback.js': {
    shouldCullModule(options, id) {
      return loadConfig['.wasm.js'].shouldCullModule(options, id) || !options.wasmFallback;
    },
    shouldEmitAsset(options, id) {
      return false;
    },
    cullingContent: `export default function () {}`
  }
};
/**
 * This is a module bundler for minigame subpacakge.
 * We need an entry script called 'game.js' for each subpackage.
 */
class ExternalWasmModuleBundler {
  constructor(options) {
    this._loadedChunkMap = {}; // id to code
    this._options = options;
  }
  _resolveId(source) {
    const id = normalizePath(path_1.default.join(this._options.externalRoot, source.substring(externalOrigin.length)));
    return id;
  }
  _load(id) {
    return __awaiter(this, void 0, void 0, function* () {
      for (const suffix in loadConfig) {
        if (id.endsWith(suffix)) {
          const config = loadConfig[suffix];
          if (config.shouldCullModule(this._options, id)) {
            return config.cullingContent;
          } else if (config.shouldEmitAsset(this._options, id)) {
            return this._emitAsset(id);
          } else {
            return yield this._transformSystemJs(id);
          }
        }
      }
      // fallback
      return yield this._transformSystemJs(id);
    });
  }
  // NOTE: we use rollup to transform CommonJS / ES Module to SystemJs.
  _transformSystemJs(id) {
    return __awaiter(this, void 0, void 0, function* () {
      const systemJsModuleId = externalOrigin + path_1.default.relative(this._options.externalRoot, id).replace(/\\/g, '/');
      const res = yield rollup.rollup({
        input: id,
        plugins: [rpCjs()]
      });
      const output = yield res.generate({
        format: 'system',
        name: systemJsModuleId
      });
      yield res.close();
      return output.output[0].code;
    });
  }
  _emitAsset(id) {
    let basename = path_1.default.basename(id);
    for (const suffixToReplace in suffixReplaceConfig) {
      const replacement = suffixReplaceConfig[suffixToReplace];
      if (basename.endsWith(suffixToReplace)) {
        // some platforms doesn't support files with special suffix like '.mem', we replace it to '.bin'
        basename = basename.slice(0, -suffixToReplace.length) + replacement;
      }
    }
    const buffer = fs_extra_1.default.readFileSync(id);
    const assetsDir = path_1.default.join(this._options.outDir, 'assets');
    fs_extra_1.default.outputFileSync(path_1.default.join(assetsDir, basename), buffer);
    // output game.js
    const gameJs = path_1.default.join(assetsDir, 'game.js');
    if (!fs_extra_1.default.existsSync(gameJs)) {
      fs_extra_1.default.outputFileSync(gameJs, `console.log('[CC Subpackage] wasm assets loaded');`, 'utf8');
    }
    return `export default 'assets/${basename}';`;
  }
  _transform(id, code) {
    if (code.startsWith('System.register')) {
      // NOTE: if it's already SystemJS module, we don't need to transform it again.
      return code;
    }
    const systemJsModuleId = externalOrigin + path_1.default.relative(this._options.externalRoot, id).replace(/\\/g, '/');
    const res = babel.transformSync(code, {
      compact: true,
      plugins: [[pluginTransformSystemJSModule, {
        moduleId: systemJsModuleId
      }]]
    });
    code = res.code;
    return code;
  }
  bundle() {
    return __awaiter(this, void 0, void 0, function* () {
      // transform all external wasm modules
      for (const externalWasmModule of this._options.externalWasmModules) {
        const id = this._resolveId(externalWasmModule);
        const code = yield this._load(id);
        this._loadedChunkMap[id] = this._transform(id, code);
      }
      // bundle
      const result = [`console.log('[CC Subpackage] wasm chunks loaded');`];
      for (const id in this._loadedChunkMap) {
        const code = this._loadedChunkMap[id];
        result.push(code);
      }
      return result.join('\n');
    });
  }
}
/**
 * This plugin enable to load script or wasm with url based on 'external://' origin.
 */
function externalWasmLoader(options) {
  const externalWasmModules = [];
  return {
    name: '@cocos/ccbuild|external-loader',
    resolveId(source, importer) {
      return __awaiter(this, void 0, void 0, function* () {
        if (source.startsWith(externalOrigin)) {
          if (options.wasmSubpackage) {
            externalWasmModules.push(source);
            return {
              id: source,
              external: true
            };
          }
          return source;
        }
        return null;
      });
    },
    load(id) {
      return __awaiter(this, void 0, void 0, function* () {
        if (id.startsWith(externalOrigin)) {
          const filePath = normalizePath(path_1.default.join(options.externalRoot, id.substring(externalOrigin.length)));
          for (const suffix in loadConfig) {
            if (filePath.endsWith(suffix)) {
              const config = loadConfig[suffix];
              if (config.shouldCullModule(options, id)) {
                return config.cullingContent;
              } else if (config.shouldEmitAsset(options, id)) {
                return emitAsset(this, filePath);
              } else {
                return yield fs_extra_1.default.readFile(filePath, 'utf8');
              }
            }
          }
          // some external module that doesn't obey the suffix specification, we return its content by default.
          return yield fs_extra_1.default.readFile(filePath, 'utf8');
        }
        return null;
      });
    },
    // Generates the `import.meta.ROLLUP_FILE_URL_referenceId`.
    resolveFileUrl({
      // > The path and file name of the emitted asset, relative to `output.dir` without a leading `./`.
      fileName,
      // > The path and file name of the emitted file,
      // > relative to the chunk the file is referenced from.
      // > This will path will contain no leading `./` but may contain a leading `../`.
      relativePath
    }) {
      switch (options.format) {
        case 'relative-from-chunk':
          return `'${relativePath}'`;
        case 'relative-from-out':
          return `'${fileName}'`;
        case 'runtime-resolved':
        default:
          return undefined;
        // return `new URL('${fileName}', import.meta.url).href`;
      }
    },

    generateBundle(opts, bundles) {
      return __awaiter(this, void 0, void 0, function* () {
        if (externalWasmModules.length !== 0) {
          const bundler = new ExternalWasmModuleBundler(Object.assign(Object.assign({}, options), {
            externalWasmModules,
            outDir: opts.dir
          }));
          const code = yield bundler.bundle();
          fs_extra_1.default.outputFileSync(path_1.default.join(opts.dir, 'chunks/game.js'), code, 'utf8');
        }
      });
    }
  };
}
exports.externalWasmLoader = externalWasmLoader;
/**
 * Convert the file path to asset ref URL.
 * @param file File path in absolute.
 */
function pathToAssetRefURL(file) {
  return `${assetPrefix}${(0, url_1.pathToFileURL)(file).pathname}`;
}
exports.pathToAssetRefURL = pathToAssetRefURL;
const assetPrefix = 'asset:';