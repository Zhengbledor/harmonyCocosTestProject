"use strict";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModuleQuery = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const platform_config_1 = require("./platform-config");
const glob_1 = __importDefault(require("glob"));
const utils_1 = require("../../utils/lib/index.js");
/**
 * The module info manager.
 */
class ModuleQuery {
  constructor(context) {
    this._resolvedCache = {}; // module name to module entry file path
    this._cachedHasEditorSpecificExport = {};
    this._context = context;
  }
  /**
   * Get all modules' name defined in engine workspaces.
   */
  getAllModules() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this._ensureModuleName2PkgJson();
      if (!this._cachedModuleName2PkgJson) {
        throw new Error(`Failed to resolve engine modules.`);
      }
      return Object.keys(this._cachedModuleName2PkgJson);
    });
  }
  /**
   * Get modules' all exports by module name.
   */
  getExports(moduleName) {
    return __awaiter(this, void 0, void 0, function* () {
      const config = yield this.getConfig(moduleName);
      const moduleExports = [];
      if (!config.exports) {
        return moduleExports;
      }
      for (let exportPort in config.exports) {
        if (exportPort === '.' || exportPort === './') {
          moduleExports.push(moduleName);
        } else {
          exportPort = utils_1.ps.join(moduleName, exportPort);
          if (exportPort.endsWith('/')) {
            exportPort = exportPort.slice(0, -1);
          }
          moduleExports.push(exportPort);
        }
      }
      return moduleExports;
    });
  }
  /**
   * Get all the modules' exports.
   */
  getAllExports() {
    return __awaiter(this, void 0, void 0, function* () {
      const allModules = yield this.getAllModules();
      const allExports = [];
      for (const moduleName of allModules) {
        allExports.push(...(yield this.getExports(moduleName)));
      }
      return allExports;
    });
  }
  /**
   * Get the map from module name to module path.
   */
  getExportMap() {
    return __awaiter(this, void 0, void 0, function* () {
      const allExports = yield this.getAllExports();
      const map = {};
      for (const exportPort of allExports) {
        const resolved = yield this.resolveExport(exportPort);
        if (resolved) {
          map[exportPort] = resolved;
        }
      }
      return map;
    });
  }
  /**
   * Resolve module package.json path by module name.
   */
  resolvePackageJson(moduleName) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this._ensureModuleName2PkgJson();
      if (!this._cachedModuleName2PkgJson) {
        throw new Error(`Failed to resolve engine modules.`);
      }
      const pkgJson = this._cachedModuleName2PkgJson[moduleName];
      if (!pkgJson) {
        throw new Error(`Failed resolve package json of module: ${moduleName}.`);
      }
      return pkgJson;
    });
  }
  /**
   * Get module config by module name.
   */
  getConfig(moduleName) {
    return __awaiter(this, void 0, void 0, function* () {
      const modulePath = yield this.resolvePackageJson(moduleName);
      if (!modulePath) {
        throw new Error(`Failed to resolve engine module: ${moduleName}.`);
      }
      return yield fs_extra_1.default.readJson(modulePath);
    });
  }
  /**
   * Resolve module entry path by import source.
   */
  resolveExport(source) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if (this._resolvedCache[source]) {
        return this._resolvedCache[source];
      }
      if (source.startsWith('.')) {
        // no relative path resolve
        return;
      }
      const allModules = yield this.getAllModules();
      const moduleName = allModules.find(moduleName => source.startsWith(moduleName));
      if (!moduleName) {
        return;
      }
      let exportPort = '.';
      if (utils_1.ps.relative(moduleName, source) !== '') {
        exportPort = './' + utils_1.ps.relative(moduleName, source);
      }
      const moduleRootDir = utils_1.ps.dirname(yield this.resolvePackageJson(moduleName));
      const config = yield this.getConfig(moduleName);
      // NOTE: '.' export port can cover all export ports.
      const rootExport = (_a = config.exports) === null || _a === void 0 ? void 0 : _a[exportPort];
      if (!rootExport) {
        return;
      }
      // custom condition
      if (this._context.customExportConditions) {
        for (const condition of this._context.customExportConditions) {
          if (typeof rootExport[condition] === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport[condition]);
          }
        }
      }
      // platform condition
      const platform = this._context.platform.toLowerCase();
      if (this._isWebPlatform(platform)) {
        if (typeof rootExport.web === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.web);
        } else if (typeof rootExport.web === 'object') {
          if (typeof rootExport.web[platform] === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.web[platform]);
          } else if (typeof rootExport.web.default === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.web.default);
          }
        }
      } else if (this._isMiniGamePlatform(platform)) {
        if (typeof rootExport.minigame === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.minigame);
        } else if (typeof rootExport.minigame === 'object') {
          if (typeof rootExport.minigame[platform] === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.minigame[platform]);
          } else if (typeof rootExport.minigame.default === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.minigame.default);
          }
        }
      } else if (this._isNativePlatform(platform)) {
        if (typeof rootExport.native === 'string') {
          return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.native);
        } else if (typeof rootExport.native === 'object') {
          if (typeof rootExport.native[platform] === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.native[platform]);
          } else if (typeof rootExport.native.default === 'string') {
            return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.native.default);
          }
        }
      }
      // types condition
      if (typeof rootExport.types === 'string') {
        return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport.types);
      } else if (typeof rootExport === 'string') {
        return this._resolvedCache[source] = utils_1.ps.join(moduleRootDir, rootExport);
      } else {
        throw new Error(`Cannot resolve export: '${source}'.`);
      }
    });
  }
  /**
   * To detect whether the module has a './editor' export.
   * @param moduleName
   */
  hasEditorSpecificExport(moduleName) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof this._cachedHasEditorSpecificExport[moduleName] === 'boolean') {
        return this._cachedHasEditorSpecificExport[moduleName];
      }
      const pkgJson = yield this.resolvePackageJson(moduleName);
      const pkg = yield fs_extra_1.default.readJson(pkgJson);
      return this._cachedHasEditorSpecificExport[moduleName] = typeof ((_a = pkg.exports) === null || _a === void 0 ? void 0 : _a['./editor']) !== 'undefined';
    });
  }
  _ensureModuleName2PkgJson() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._cachedModuleName2PkgJson) {
        return;
      }
      const enginePkg = yield fs_extra_1.default.readJson(utils_1.ps.join(this._context.engine, 'package.json'));
      let pkgFiles = [];
      if (enginePkg.workspaces) {
        for (const ws of enginePkg.workspaces) {
          pkgFiles.push(...glob_1.default.sync(utils_1.ps.join(this._context.engine, ws), {
            ignore: '**/node_modules/**/*'
          }));
        }
      }
      pkgFiles = pkgFiles.map(file => {
        if (fs_extra_1.default.statSync(file).isDirectory()) {
          const pkgFile = utils_1.ps.join(file, 'package.json');
          if (fs_extra_1.default.existsSync(pkgFile)) {
            return pkgFile;
          }
        }
        return file;
      });
      pkgFiles = pkgFiles.filter(file => file.endsWith('package.json'));
      pkgFiles = pkgFiles.filter((file, index) => pkgFiles.indexOf(file) === index);
      this._cachedModuleName2PkgJson = {};
      for (const pkg of pkgFiles) {
        const name = (yield fs_extra_1.default.readJson(pkg)).name;
        this._cachedModuleName2PkgJson[name] = pkg;
      }
    });
  }
  _isWebPlatform(platform) {
    return platform.toUpperCase() in platform_config_1.WebPlatform || platform.toUpperCase() === 'HTML5';
  }
  _isMiniGamePlatform(platform) {
    return platform.toUpperCase() in platform_config_1.MinigamePlatform;
  }
  _isNativePlatform(platform) {
    return platform.toUpperCase() in platform_config_1.NativePlatform || platform.toUpperCase() === 'NATIVE';
  }
}
exports.ModuleQuery = ModuleQuery;